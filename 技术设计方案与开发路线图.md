# 技术设计方案与开发路线图

## 1. 技术选型分析

- 运行时与编译：采用 .NET 10 + NativeAOT，启用 Trimming 与 InvariantGlobalization，避免运行时反射与不确定元数据访问。
- JSON 序列化：使用 System.Text.Json + Source Generator，完全替代 Newtonsoft.Json，确保 AOT 友好与高性能。
- RTSP 录制：参考 RtspRecorder 的核心实现（若使用 RtspClientSharp 或 FFmpeg.AutoGen，则通过适配器封装为服务）。对第三方库的依赖进行隔离，避免其反射依赖影响裁剪。
- 实时通信：优先使用 SignalR（服务端与 Blazor WASM 客户端均可 AOT 兼容，基于 System.Text.Json），若出现 AOT 限制则降级为原生 WebSocket + JSON 协议。
- 日志：使用 Microsoft.Extensions.Logging + 轻量文件日志提供器（每日滚动），避免依赖反射型第三方日志库导致裁剪问题。
- 系统命令：通过 System.Diagnostics.Process 调用 mediainfo（假设宿主环境已安装）。

### 关键 NuGet 包（AOT 友好理由）

- Microsoft.AspNetCore.App：Minimal API 与基础中间件所在的共享框架。
- Microsoft.AspNetCore.SignalR：服务端实时通信，使用 System.Text.Json 序列化，AOT 友好。
- Microsoft.AspNetCore.SignalR.Client：WASM 客户端连接，避免反射型序列化。
- Microsoft.AspNetCore.Components.WebAssembly：Blazor WASM 前端宿主，AOT 可兼容。
- System.Text.Json：内置库，支持 Source Generator，避免反射。
- System.Threading.Channels：高性能并发队列，纯托管实现，AOT 友好。
- 参考库依赖：以 RtspRecorder 所使用的核心库为准，封装到 RecordingEngine 中，确保可替换与隔离。

### 前后端通信方案

- 首选 SignalR：定义强类型消息 DTO，引入 System.Text.Json Source Generator 进行序列化；服务端与客户端均注册同一 JsonSerializerContext，确保 AOT 无反射。
- 备选 WebSocket：自定义文本协议（JSON），统一使用 JsonSerializerContext；在极端情况下替代 SignalR。

## 2. 架构设计

### 项目结构（Solution）

- Server：Minimal API、调度、录制服务、SignalR、静态文件托管、配置管理、日志。
- Client：Blazor WebAssembly UI。
- Shared：DTO、枚举、JsonSerializerContext（源生成器）、基础工具类型。
- RecordingEngine（可选独立项目）：封装 RtspRecorder 参考库，实现 IRecordingService。

### 核心类设计

- RecordingManager
  - 维护任务队列与正在录制的任务集合（ConcurrentDictionary）。
  - 使用 Channel/Queue 管理 Pending 任务。
  - 控制最大并发 `maxRecordingTasks`。
  - 统一 Start/Stop 调用 IRecordingService，并更新任务状态。
  - 将状态变化通过 SignalR 推送到前端。

- ConfigurationService
  - 负责 appsettings.json 与 channels.json 的读取与写入。
  - 使用 ReaderWriterLockSlim 保障多线程读写安全。
  - 写入采用临时文件 + 原子替换策略，避免半写入与文件损坏。
  - 使用 System.Text.Json Source Generator 进行序列化与反序列化。

### 数据流向图（文字描述）

1. 用户在 WebUI 点击“开始录制”。
2. Client 调用 Minimal API 创建任务，后端写入内存列表（可选持久化 tasks.json）。
3. BackgroundService 每秒轮询检测任务时间与并发限制。
4. 满足条件后 RecordingManager 启动 IRecordingService。
5. IRecordingService 连接 RTSP → 拉流 → 写入文件（记录目录 recordPath）。
6. 录制过程更新进度与状态（已录大小、进度条比例等）。
7. SignalR 推送状态变化到前端页面。
8. 录制完成后更新任务状态，并提供查看/下载/删除操作。

## 3. 关键逻辑伪代码

### BackgroundService 轮询核心逻辑

```pseudo
while not stopping:
    now = UtcNow()
    foreach task in PendingTasks:
        if now < task.StartTime:
            continue

        // 强制等待 30 秒，避免回放源尚未生成
        if now < task.StartTime + 30s:
            continue

        if ActiveCount >= MaxRecordingTasks:
            continue

        startRecording(task)
    sleep(1s)
```

### Minimal API + NativeAOT 托管 Blazor 静态文件

```pseudo
builder.Services.AddRazorPages()
builder.Services.AddSignalR()
builder.Services.AddSingleton<RecordingManager>()
builder.Services.AddHostedService<RecordingBackgroundService>()

app.UseDefaultFiles()
app.UseStaticFiles()
app.MapFallbackToFile("index.html")

app.MapHub<RecordingHub>("/hubs/recording")
app.MapMinimalApiEndpoints()

app.Run()
```

## 4. 潜在风险评估

- AOT + 反射依赖：第三方 RTSP 库或日志库可能依赖反射，裁剪后运行失败。  
  解决：封装适配层并预留替代实现；尽量使用托管、少反射的库；必要时通过动态依赖描述文件（rd.xml）或保留元数据策略解决。
- SignalR 序列化：默认基于反射生成元数据。  
  解决：为所有 DTO 提供 System.Text.Json Source Generator，并在服务端与客户端注册统一的 JsonSerializerContext。
- Blazor WASM 托管：NativeAOT 与静态文件服务组合需验证。  
  解决：最小化中间件链路，避免动态路由与反射；确保 MapFallbackToFile 正常工作。
- mediainfo 调用：依赖系统环境命令。  
  解决：启动时检测命令可用性并提示；不可用时降级为 FFmpeg 库（前提 AOT 兼容）。
- 文件并发写入与 IO 冲突：多任务同时写入可能导致性能瓶颈。  
  解决：每任务独立文件名与目录层级隔离；采用顺序写入与合理缓冲；IO 失败重试策略。
- 国际化/本地化：AOT 裁剪下的文化数据可能缺失。  
  解决：启用 InvariantGlobalization 与固定格式化策略；UI 禁用国际化或最小化依赖。

## 5. 开发步骤规划

1. 搭建 Solution 与 Shared 模型：创建 Server/Client/Shared 结构与 DTO、枚举、JsonSerializerContext。
2. 配置与任务存储层：实现 ConfigurationService、任务管理模型、JSON 读写与线程安全。
3. 录制引擎封装：根据 RtspRecorder 参考代码封装 IRecordingService。
4. 后台调度与状态推送：BackgroundService + RecordingManager + SignalR 推送。
5. Minimal API 与 WebUI：实现任务 CRUD、频道管理、配置页与录制管理页。
6. AOT 编译与发布验证：完善发布参数，修复裁剪问题，验证 NativeAOT 可运行。

---

附：配置文件（System.Text.Json 源生成器读取），appsettings.json 与 channels.json 结构同原始需求，避免使用 Newtonsoft.Json 并确保裁剪安全。
